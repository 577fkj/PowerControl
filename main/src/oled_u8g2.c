#include <stdio.h>
#include <string.h>
#include "main.h"
#include "esp_err.h"
#include "u8g2.h"
#include "driver/gpio.h"
#include "driver/spi_master.h"
#include "sdkconfig.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_log.h"

#define TAG "OLED"

u8g2_t u8g2;
static spi_device_handle_t handle_spi; // SPI handle.

uint8_t u8g2_byte_cb(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
    switch (msg)
    {
    case U8X8_MSG_BYTE_SET_DC:
        gpio_set_level(OLED_DC, arg_int);
        break;

    case U8X8_MSG_BYTE_INIT:
    {
        spi_bus_config_t bus_config = {
            .sclk_io_num = OLED_CLK,      // CLK
            .mosi_io_num = OLED_SDA,      // MOSI
            .miso_io_num = GPIO_NUM_NC,   // MISO
            .quadwp_io_num = GPIO_NUM_NC, // Not used
            .quadhd_io_num = GPIO_NUM_NC, // Not used
            .max_transfer_sz = 0,
            .flags = 0,
        };
        ESP_LOGI(TAG, "... Initializing bus.");
        ESP_ERROR_CHECK(spi_bus_initialize(SPI2_HOST, &bus_config, SPI_DMA_CH_AUTO));

        spi_device_interface_config_t dev_config;
        memset(&dev_config, 0, sizeof(spi_device_interface_config_t));
        dev_config.clock_speed_hz = 10000000;
        dev_config.spics_io_num = OLED_CS;
        dev_config.queue_size = 200;
        ESP_LOGI(TAG, "... Adding device bus.");
        ESP_ERROR_CHECK(spi_bus_add_device(SPI2_HOST, &dev_config, &handle_spi));
        break;
    }

    case U8X8_MSG_BYTE_SEND:
    {
        spi_transaction_t trans_desc;
        memset(&trans_desc, 0, sizeof(spi_transaction_t));
        trans_desc.length = arg_int * 8;
        trans_desc.tx_buffer = arg_ptr;

        // ESP_LOGI(TAG, "... Transmitting %d bytes.", arg_int);
        // ESP_LOG_BUFFER_HEXDUMP(TAG, arg_ptr, arg_int, ESP_LOG_INFO);
        ESP_ERROR_CHECK(spi_device_transmit(handle_spi, &trans_desc));
        break;
    }
    }
    return 0;
} // u8g2_esp32_spi_byte_cb

uint8_t u8g2_delay_cb(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{

    switch (msg)
    {
        // Initialize the GPIO and DELAY HAL functions.  If the pins for DC and
        // RESET have been specified then we define those pins as GPIO outputs.
    case U8X8_MSG_GPIO_AND_DELAY_INIT:
    {
        uint64_t bitmask = 0;
        bitmask = bitmask | (1ull << OLED_DC);
        bitmask = bitmask | (1ull << OLED_RESET);
        bitmask = bitmask | (1ull << OLED_CS);

        if (bitmask == 0)
        {
            break;
        }
        gpio_config_t gpioConfig;
        gpioConfig.pin_bit_mask = bitmask;
        gpioConfig.mode = GPIO_MODE_OUTPUT;
        gpioConfig.pull_up_en = GPIO_PULLUP_DISABLE;
        gpioConfig.pull_down_en = GPIO_PULLDOWN_ENABLE;
        gpioConfig.intr_type = GPIO_INTR_DISABLE;

        esp_err_t err = gpio_config(&gpioConfig);
        if (err != ESP_OK)
        {
            ESP_LOGE(TAG, "Unable to configure GPIO pins: %s", esp_err_to_name(err));
            break;
        }
        else
        {
            ESP_LOGI(TAG, "GPIO pins configured");
        }
        break;
    }

        // Set the GPIO reset pin to the value passed in through arg_int.
    case U8X8_MSG_GPIO_RESET:
        ESP_LOGI(TAG, "GPIO reset: %d", arg_int);
        gpio_set_level(OLED_RESET, arg_int);
        break;
        // Set the GPIO client select pin to the value passed in through arg_int.
    case U8X8_MSG_GPIO_CS:
        break;
        // Set the Software I²C pin to the value passed in through arg_int.
    case U8X8_MSG_GPIO_I2C_CLOCK:
        break;
        // Set the Software I²C pin to the value passed in through arg_int.
    case U8X8_MSG_GPIO_I2C_DATA:
        break;
        // Delay for the number of milliseconds passed in through arg_int.
    case U8X8_MSG_DELAY_MILLI:
        vTaskDelay(arg_int / portTICK_PERIOD_MS);
        break;
    }
    return 0;
} // u8g2_esp32_gpio_and_delay_cb

void oled_init()
{
    u8g2_Setup_sh1106_128x64_noname_f(&u8g2, U8G2_R2, u8g2_byte_cb, u8g2_delay_cb);
    u8g2_InitDisplay(&u8g2);
    // u8g2_ClearDisplay(&u8g2);
    u8g2_SetPowerSave(&u8g2, 0);
    u8g2_ClearBuffer(&u8g2);
}

const unsigned char col[] U8X8_PROGMEM = {0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xef, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x83, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0x00, 0xfe, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x3f, 0x00, 0xfc, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x1f, 0x00, 0xf0, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x07, 0x00, 0xc0, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x01, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x02, 0x00, 0x00, 0x7c, 0x00, 0x3c, 0x00, 0x8f, 0x07, 0x00, 0x78, 0x00, 0x7c, 0x00, 0xbe, 0x07, 0x00, 0x00, 0x78, 0x00, 0x22, 0x00, 0x91, 0x04, 0xfc, 0x47, 0x00, 0x44, 0x00, 0xbe, 0x1f, 0x00, 0x00, 0x78, 0xe0, 0xc3, 0x0f, 0xe1, 0x18, 0x04, 0xc6, 0xc3, 0xc7, 0x0f, 0xbe, 0x3f, 0x00, 0x00, 0x78, 0x10, 0x00, 0x08, 0x21, 0x20, 0x04, 0x01, 0x24, 0x00, 0x10, 0xbe, 0xff, 0x01, 0x00, 0x78, 0x10, 0x00, 0x88, 0x21, 0x20, 0xfc, 0x01, 0x24, 0x00, 0x10, 0xbe, 0xff, 0x07, 0x00, 0x78, 0x10, 0x00, 0x48, 0x40, 0x20, 0x02, 0x43, 0x24, 0x00, 0x10, 0xbe, 0xf7, 0x0f, 0x00, 0x78, 0xe0, 0xf1, 0x47, 0xc0, 0x24, 0x02, 0x44, 0x24, 0x00, 0x10, 0xbe, 0xe7, 0x1f, 0x00, 0x78, 0x00, 0x01, 0x86, 0xc0, 0x40, 0x02, 0x46, 0xc4, 0xc3, 0x11, 0xbe, 0x87, 0x3f, 0x00, 0x78, 0x00, 0x01, 0x04, 0x31, 0x80, 0xcc, 0x43, 0x04, 0x42, 0x11, 0xbe, 0x07, 0x3e, 0x00, 0x78, 0x80, 0x00, 0x04, 0x11, 0x80, 0x44, 0x62, 0x04, 0x22, 0x11, 0xbe, 0x07, 0x3e, 0x00, 0x78, 0x80, 0x70, 0x04, 0xf1, 0x78, 0x44, 0x62, 0x04, 0x21, 0x11, 0xbe, 0x07, 0x3e, 0x00, 0x78, 0x40, 0x48, 0x84, 0x41, 0x18, 0x44, 0x64, 0x84, 0x20, 0x11, 0xbe, 0x07, 0x3e, 0x00, 0x78, 0x20, 0x78, 0x84, 0x20, 0x60, 0x02, 0x64, 0x44, 0xf0, 0x11, 0xbe, 0x07, 0x3e, 0x00, 0x78, 0x10, 0x0c, 0x44, 0x10, 0x82, 0x02, 0x14, 0x24, 0x30, 0x10, 0xbe, 0x07, 0x3e, 0x00, 0x78, 0x10, 0x0a, 0xc4, 0x18, 0x86, 0x02, 0x14, 0x24, 0x28, 0x10, 0xbe, 0x1f, 0x3e, 0x00, 0x78, 0x10, 0x09, 0x82, 0x1f, 0x8d, 0xfc, 0x13, 0x26, 0x26, 0x08, 0xbe, 0x7f, 0x3e, 0x00, 0x78, 0xe0, 0xf0, 0x01, 0xf0, 0x78, 0x00, 0xfe, 0xc3, 0xe1, 0x07, 0x1e, 0xff, 0x3e, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xfc, 0x3f, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xf3, 0x3f, 0x80, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xcf, 0x3f, 0xe0, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x3f, 0x3e, 0xf8, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0x1a, 0xfe, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x81, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xe7, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
void start_ani()
{
    u8g2_ClearBuffer(&u8g2);
    u8g2_DrawXBMP(&u8g2, 6, 13, 119, 40, col);
    u8g2_SendBuffer(&u8g2);
}